/*
Copyright (c) 2016 IBM Corporation and other Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.

Contributors:
Kim Letkeman - Initial Contribution
Howard McKinney- Initial Contribution
*/

// IoT Blockchain Demo Smart Contract
// v1   KL 20 Jan 2016 Initial contract supporting multiple assets with temp and gforce
// v1.1 KL 25 Jan 2016 Fixed a few issues, added setState to allow arbitrary JSON arg, added contract state management
// v2   KL 29 Jan 2016 CRUD pattern, remove deleted tracking, added JSON object models
// v2.1 KL 01 Feb 2016 Add location
// v2.2 KL 02-03 Feb 2016 timestamp detection and adjustment, add structures for event tracking, general cleanup
// v2.3 KL 02-04 Feb 2016 return nil from deploy and invoke, []byte from query
// v2.4 KL 06-10 Feb 2016 bulk arg, add read all assets, replace event history prototype with state history
// v2.5 KL 10 Feb 2016 RFC3339 timestamps, add extension field, use maps instead of structs, add deleteAllAssets
// v2.6 KL 14 Feb 2016 add Carrier, add readAssetHistory() to isolate the use of history from contract state
// v2.7 KL 16 Feb 2016 new API readAssetHistory map of asset to ordered array latest first parameterized count
//                     new API readRecentStates ordered array latest first of any state change max 20
//                     recent states will never show more than the number of assets, as they must be unique
// v2.8 KL 17-21 Feb 2016 AlertStatus in separate file, rules engine in separate file
//                        separate the recent states to their own file
//                        align readAsset and readAllAssets output
// v2.9 KL 22 Feb 2016 inCompliance bool with addition to rules engine to handle it
//                     event string saving original arg for this state change
//                     delete readonly fields to avoid contamination of state, note that original event contains all sent fields
//                     renamed contract and folder to iot_blockchain_tradelane_beta_contract
// v3.0 HM 25 Feb 2016 Change where asset state history is stored -- store it in it's own bucket in the ledger.
//                     Moved the asset state history code into a separate package.
// v3.0.1 HM 03 Mar 2016 Store the state history in descending order.
// v3.0.2 KL 03 Mar 2016 Added a more complete sample object and a new API for the schema (generated by
//                       the new generator for 3.1). No impact on tests except for version change.
//                       also debuts the addition of readAssetEventSchema
// v3.0.3 KL 07 Mar 2016 production version with print statements suppressed
// v4.0 KL 09-10 Mar 2016 renumbered to 4.0 because the schema changes are API breaking
//                     remove state caching for contract state, recent states, separated contract state into module
//                     ripped out bulk interface as it is guaranteed to create state inconsistencies
//                     deepMerge for maps of incoming event and ledger state
//         11 Mar 2016 reversed inCompliance to noncompliant so that the normal compliant contract does not have
//                     any space taken up by the compliance section
// v3.0.4 KL 14-15 Mar 2016 backport statelessness from 4.0, logging from 4.0,
//                          remove bulk from 4.0, contractState module from 4.0
//                          cleaned up recenStates output, wrote new logging module
//           16 Mar 2016 fix alerts, merge example folder version with the hyperledger version (oops!),
//                       add nickname, clean up logging
// v3.0.5 KL 27 Mar 2016 add case insensitive JSON-RPC mode so that customers
//                       can choose how they want case handled on the wire
// v4.0   KL 15 April 2016 Adapt contract to Hyperledger. Change shim imports. Add Init function.
//                         Rename Run to Invoke. Change schema to add new /chaincode service end point etc.
//                         Remove state structs (use schema and mapUtils.) Make fixes based on lint, e.g. fmt.Errorf.
//                         Update all docs to reflect the changes.
// v4.1   KL May 27 2016 Store transaction UUID and timestamp in the state, aligning world state with the transaction
//                       (and by definition the block) that is responsible for this specific asset state. Note: Initial
//                       commit of this version was at 4.0 and was in the trade lane folder. Subsequently moved to the iot
//                       folder and updated to 4.1. Also:
//                         - Additional feature in 4.1 -- issue #4 -- rules engine must return err
//                         - Tweaks to deletePropertiesFromAsset (a bug found in the alert boilerplate using args instead of ledger)
//                         - Added postman tests for delete properties from asset and validation test rules
//                         - Reordered and normalized the rules engine call to make original event available and have consistency
//                           between create, update and delete properties.
// v4.2 KL May 28 2016 Replace all occurences of "incompliance" with "compliant" to remove an obvious source of confusion.
//                     Remove a copy paste error in the new testValidation rule where it was falling through and clearing
//                     the OVERTEMP rule, causing total havoc with that rule.

//************** Life begins as simple aviation contract

// v4.2sa KL June 24-28  Schema for simple life limited part scenario with a couple of alerts.
// v4.3 KL July-August 2016  Move simple aviation changes into aviation contract to begin expansion into multiple assets and events with indexes etc.
// v4.4 KL August 2016  Create assetCommon.go for easy addition of new assets.
//      Create crudCommon.go for common functions in service of assets and events.
//      Create contractConfig.go to encompass static and dynamic contract configuration.
//        Create aircraftAssemblyConnect.go as a two-way inverted index of the 1:* relation.
//        Create asset sidecar go files for airline, aircraft and assembly.
//        Create event sidecar go files for flight, maintenance, inspection and analyticAdjustment.
//        Update payloadSchema.json with asset and event definitions
//        Create filters.go to enable complex filtering of queries, which helps with simple
//            relationships like airline to airplane, which are not worth the time to
//            implement a separate inverted index as was done for aircraft to assemblies.
//        Significant refactoring of main.go for asset and event APIs
//        Updates to mapUtils to improve reliability and add cleaner support for float, etc.

package main

import (
    "encoding/json"
    "errors"
    "fmt"
    "github.com/hyperledger/fabric/core/chaincode/shim"
    "strings"
)

//go:generate go run scripts/generate_go_schema.go

//***************************************************
//***************************************************
//* CONTRACT initialization and runtime engine
//***************************************************
//***************************************************

// ************************************
// definitions
// ************************************

// SimpleChaincode is the receiver for all shim API
type SimpleChaincode struct {
}

// ASSETID is the JSON tag for the assetID
const ASSETID string = "common.assetID"

// EVENTNAME is the JSON tag for the the event type for any incoming CRUD event
const EVENTNAME string = "common.eventName"

// TIMESTAMP is the JSON tag for timestamps, devices must use this tag to be compatible!
const TIMESTAMP string = "common.timestamp"

// TXNTIMESTAMP is the JSON tag for transaction timestamps, which map directly onto the transaction in the blockchain
const TXNTIMESTAMP string = "txntimestamp"

// TXNUUID is the JSON tag for transaction UUIDs, which map directly onto the transaction in the blockchain
const TXNUUID string = "txnuuid"

// ArgsMap is a generic map[string]interface{} to be used as a receiver
type ArgsMap map[string]interface{}

var log = NewContractLogger(DEFAULTNICKNAME, DEFAULTLOGGINGLEVEL)

// ************************************
// start the message pumps
// ************************************
func main() {
    err := shim.Start(new(SimpleChaincode))
    if err != nil {
        log.Infof("ERROR starting Simple Chaincode: %s", err)
    }
}

// Init is called in deploy mode when contract is initialized
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    var stateArg ContractState
    var err error

    log.Info("Entering INIT")

    if len(args) != 1 {
        err = errors.New("init expects one argument, a JSON string with  mandatory version and optional nickname")
        log.Critical(err)
        return nil, err
    }

    err = json.Unmarshal([]byte(args[0]), &stateArg)
    if err != nil {
        err = fmt.Errorf("Version argument unmarshal failed: %s", err)
        log.Critical(err)
        return nil, err
    }

    if stateArg.Nickname == "" {
        stateArg.Nickname = DEFAULTNICKNAME
    }

    (*log).setModule(stateArg.Nickname)

    err = initializeContractState(stub, stateArg.Version, stateArg.Nickname)
    if err != nil {
        return nil, err
    }

    err = dynamicConfigInit(stub)
    if err != nil {
        return nil, err
    }

    err = initAircraftAssemblyIndexes(stub)
    if err != nil {
        return nil, err
    }

    log.Info("Contract initialized")
    return nil, nil
}

// Invoke is called in invoke mode to delegate state changing function messages
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    // asset CRUD API
    if function == "createAssetAirline" {
        return t.createAssetAirline(stub, args)
    } else if function == "createAssetAircraft" {
        return t.createAssetAircraft(stub, args)
    } else if function == "createAssetAssembly" {
        return t.createAssetAssembly(stub, args)
    } else if function == "updateAssetAirline" {
        return t.updateAssetAirline(stub, args)
    } else if function == "updateAssetAircraft" {
        return t.updateAssetAircraft(stub, args)
    } else if function == "updateAssetAssembly" {
        return t.updateAssetAssembly(stub, args)
    } else if function == "deleteAssetAirline" {
        return t.deleteAssetAirline(stub, args)
    } else if function == "deleteAssetAircraft" {
        return t.deleteAssetAircraft(stub, args)
    } else if function == "deleteAssetAssembly" {
        return t.deleteAssetAssembly(stub, args)
    } else if function == "deleteAllAssetsAirline" {
        return t.deleteAllAssetsAirline(stub, args)
    } else if function == "deleteAllAssetsAircraft" {
        return t.deleteAllAssetsAircraft(stub, args)
    } else if function == "deleteAllAssetsAssembly" {
        return t.deleteAllAssetsAssembly(stub, args)
    } else if function == "deletePropertiesFromAssetAirline" {
        return t.deletePropertiesFromAssetAirline(stub, args)
    } else if function == "deletePropertiesFromAssetAircraft" {
        return t.deletePropertiesFromAssetAircraft(stub, args)
    } else if function == "deletePropertiesFromAssetAssembly" {
        return t.deletePropertiesFromAssetAssembly(stub, args)

        // event API
    } else if function == "eventFlight" {
        return eventFlight(stub, args)
    } else if function == "eventInspection" {
        return eventInspection(stub, args)
    } else if function == "eventAnalyticAdjustment" {
        return eventAnalyticAdjustment(stub, args)
    } else if function == "eventMaintenance" {
        return eventMaintenance(stub, args)

        // contract dynamic config API
    } else if function == "updateContractConfig" {
        return nil, updateContractConfig(stub, args)

        // contract state / behavior API
    } else if function == "setLoggingLevel" {
        return nil, t.setLoggingLevel(stub, args)
    } else if function == "setCreateOnUpdate" {
        return nil, t.setCreateOnUpdate(stub, args)

        // debugging API
    } else if function == "deleteWorldState" {
        return nil, t.deleteWorldState(stub)
    }
    err := fmt.Errorf("Invoke received unknown invocation: %s", function)
    log.Warning(err)
    return nil, err
}

// Query is called in query mode to delegate non-state-changing queries
func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    // asset CRUD API
    if function == "readAssetAirline" {
        return t.readAssetAirline(stub, args)
    } else if function == "readAssetAircraft" {
        return t.readAssetAircraft(stub, args)
    } else if function == "readAssetAssembly" {
        return t.readAssetAssembly(stub, args)
    } else if function == "readAllAssetsAirline" {
        return t.readAllAssetsAirline(stub, args)
    } else if function == "readAllAssetsAircraft" {
        return t.readAllAssetsAircraft(stub, args)
    } else if function == "readAllAssetsAssembly" {
        return t.readAllAssetsAssembly(stub, args)
    } else if function == "readAssetAirlineHistory" {
        return t.readAssetAirlineHistory(stub, args)
    } else if function == "readAssetAircraftHistory" {
        return t.readAssetAircraftHistory(stub, args)
    } else if function == "readAssetAssemblyHistory" {
        return t.readAssetAssemblyHistory(stub, args)
    } else if function == "readAssetAircraftComplete" {
        return t.readAssetAircraftComplete(stub, args)

        // contract dynamic config API
    } else if function == "readContractConfig" {
        return readContractConfig(stub, args)

        // contract state / behavior API
    } else if function == "readRecentStates" {
        return readRecentStates(stub)
    } else if function == "readAssetSamples" {
        return t.readAssetSamples(stub, args)
    } else if function == "readAssetSchemas" {
        return t.readAssetSchemas(stub, args)
    } else if function == "readContractObjectModel" {
        return t.readContractObjectModel(stub, args)
    } else if function == "readContractState" {
        return t.readContractState(stub, args)

        // debugging API
    } else if function == "readWorldState" {
        return t.readWorldState(stub)
    }
    err := fmt.Errorf("Query received unknown invocation: %s", function)
    log.Warning(err)
    return nil, err
}

//***************************************************
//***************************************************
//* CONTRACT STATE
//***************************************************
//***************************************************

func (t *SimpleChaincode) readContractState(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var err error

    if len(args) != 0 {
        err = errors.New("Too many arguments. Expecting none.")
        log.Error(err)
        return nil, err
    }

    // Get the state from the ledger
    chaincodeBytes, err := stub.GetState(CONTRACTSTATEKEY)
    if err != nil {
        err = fmt.Errorf("readContractState failed GETSTATE: %s", err)
        log.Error(err)
        return nil, err
    }

    return chaincodeBytes, nil
}

//***************************************************
//***************************************************
//* CONTRACT METADATA / SCHEMA INTERFACE
//***************************************************
//***************************************************

// ************************************
// readAssetSamples
// ************************************
func (t *SimpleChaincode) readAssetSamples(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    return []byte(samples), nil
}

// ************************************
// readAssetSchemas
// ************************************
func (t *SimpleChaincode) readAssetSchemas(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    return []byte(schemas), nil
}

// ************************************
// readContractObjectModel
// ************************************
func (t *SimpleChaincode) readContractObjectModel(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var state = ContractState{MYVERSION, DEFAULTNICKNAME}

    stateJSON, err := json.Marshal(state)
    if err != nil {
        err := fmt.Errorf("JSON Marshal failed for get contract object model empty state: %+v with error [%s]", state, err)
        log.Error(err)
        return nil, err
    }
    return stateJSON, nil
}

// ************************************
// setLoggingLevel
// ************************************
func (t *SimpleChaincode) setLoggingLevel(stub shim.ChaincodeStubInterface, args []string) error {
    type LogLevelArg struct {
        Level string `json:"logLevel"`
    }
    var level LogLevelArg
    var err error
    if len(args) != 1 {
        err = errors.New("Incorrect number of arguments. Expecting a JSON encoded LogLevel.")
        log.Error(err)
        return err
    }
    err = json.Unmarshal([]byte(args[0]), &level)
    if err != nil {
        err = fmt.Errorf("setLoggingLevel failed to unmarshal arg: %s", err)
        log.Error(err)
        return err
    }
    for i, lev := range logLevelNames {
        if strings.ToUpper(level.Level) == lev {
            (*log).SetLoggingLevel(LogLevel(i))
            return nil
        }
    }
    err = fmt.Errorf("Unknown Logging level: %s", level.Level)
    log.Error(err)
    return err
}

// CreateOnUpdate is a shared parameter structure for the use of
// the createonupdate feature
type CreateOnUpdate struct {
    CreateOnUpdate bool `json:"createOnUpdate"`
}

// ************************************
// setCreateOnUpdate
// ************************************
func (t *SimpleChaincode) setCreateOnUpdate(stub shim.ChaincodeStubInterface, args []string) error {
    var createOnUpdate CreateOnUpdate
    var err error
    if len(args) != 1 {
        err = errors.New("setCreateOnUpdate expects a single parameter")
        log.Error(err)
        return err
    }
    err = json.Unmarshal([]byte(args[0]), &createOnUpdate)
    if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to unmarshal arg: %s", err)
        log.Error(err)
        return err
    }
    err = PUTcreateOnUpdate(stub, createOnUpdate)
    if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to PUT setting: %s", err)
        log.Error(err)
        return err
    }
    return nil
}

// PUTcreateOnUpdate marshals the new setting and writes it to the ledger
func PUTcreateOnUpdate(stub shim.ChaincodeStubInterface, createOnUpdate CreateOnUpdate) (err error) {
    createOnUpdateBytes, err := json.Marshal(createOnUpdate)
    if err != nil {
        err = errors.New("PUTcreateOnUpdate failed to marshal")
        log.Error(err)
        return err
    }
    err = stub.PutState("CreateOnUpdate", createOnUpdateBytes)
    if err != nil {
        err = fmt.Errorf("PUTSTATE createOnUpdate failed: %s", err)
        log.Error(err)
        return err
    }
    return nil
}

// canCreateOnUpdate retrieves the setting from the ledger and returns it to the calling function
func canCreateOnUpdate(stub shim.ChaincodeStubInterface) bool {
    var createOnUpdate CreateOnUpdate
    createOnUpdateBytes, err := stub.GetState("CreateOnUpdate")
    if err != nil {
        err = fmt.Errorf("GETSTATE for canCreateOnUpdate failed: %s", err)
        log.Error(err)
        return true // true is the default
    }
    err = json.Unmarshal(createOnUpdateBytes, &createOnUpdate)
    if err != nil {
        err = fmt.Errorf("canCreateOnUpdate failed to marshal: %s", err)
        log.Error(err)
        return true // true is the default
    }
    return createOnUpdate.CreateOnUpdate
}
